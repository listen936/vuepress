# 数据结构和算法基础知识



## 数据结构

通俗的讲，数据结构就是存储数据的结构，数据结构中有8大分类

* 数组
* 栈
* 队列
* 链表
* 树
* 散列表(哈希表)
* 堆
* 图

### 数组

* 数组是可以在内存中连续存储多个元素的数据结构
* 在内存中的分配也是连续的
* 可以通过下标进行访问

### 栈

* 先进后出
* 只允许操作栈顶，不允许操作栈底
* 适用于实现递归方面的场景

### 队列

* 先进先出
* 适用于多线程阻塞队列管理

### 链表

* 在物理存储单元上是非连续的、非顺序的存储结构
* 每个元素包含2个节点，一个存储数据，一个存储只想下一个节点的指针
* 根据指针的指向可以形成不同的结构，单链表，双向链表，循环链表等

### 树

* 由n(n>=1)个有限节点组成一个具有层次关系的集合
* 每个节点有0或多个子节点
* 没有父节点的节点为根节点
* 每一个非根节点有且只有一个父节点
* 除了根节点，每个子节点都可以分成多个不相交的子树
* 二叉树是特殊的一种树，还有平衡二叉树、红黑树、B+树

### 哈希表(散列表)

* 根据键和值进行直接访问的数据结构
* 对应js中的set、map

### 堆

* 类似树的数组对象
* 总是一棵完全二叉树
* 因为堆有序的特点，可用于数组中的排序，堆排序

### 图

* 由节点和边组成
* 根据顶点的指向方向可分为无向图和有向图




## 算法

> 百度百科释义：算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制...一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

通俗的讲就是操作数据的方法。算法只能作用于特定的数据结构，而数据结构又会根据自身的特点推演出特定的算法

### 时间复杂度
通常用来描述当前算法执行所消耗的时间

### 空间复杂度
通常用来描述执行当前算法所消耗的内存空间

### 大O符号表示法

想知道一个算法的复杂度，通常会想到的是运行一遍算法，然后看一下运行时间和消耗的内存，但这样会有一些弊端，比如在不同的机器的表现会相差很大，不同的数据量的结果也会不一样。所以就有了一种不依赖测试环境、具体数据，可以粗略估计算法执行效率的方法——`大O符号表示法`

* 公式 `T(n) = O(f(n))`
* 只关注执行次数最多的那段代码,且**忽略系数、常量、对数的底**
* 关注代码的执行次数


### 常见的复杂度

1. 常数阶O(1)

    无论执行多少行代码，只要没有循环等复杂结构，那么这个代码的时间复杂度就都是O(1)

```js
    let i = 1;
    i++;
    let j = i * 10

```

2. 线性阶O(n) 

```js
     let sum = 0  // 第一行  执行1次
     for(let i  = 0; i < n; i++) { // 第二行  执行n次
         sum += i // 第三行  执行n次
     }
    // T(n) = 1+n+n = 1+2n  常数和系数都意义不大，可以忽略;只关注执行次数最多的那行代码
    // 所以T(n) = O(n)
```
3. 对数阶O(logN)

```js
    let i  = 1
    while(i < n) {
        i = i* 2
    }
    // 假设执行次数为x
    // 2^0  2^1 2^2…… 2^x = n
    // x = 以2为底的logn 忽略对数的底
    // T(n) = O(logn)
```

4. 线性对数阶O(nlogn)

```js
    for(let i = 0; i < n; i++) {
        let j = 1
        while(j < n) {
            j= j * i
        }
    }
    // 简单的理解就是复杂度为O(logn)的代码循环n遍

```
5. 平方阶O(n²)

```js
    for(let i = 0; i < n; i++) {
        for(let j = 1; j< n ;j++) {
            ...
        }
    }
    // 简单的理解就是复杂度为O(n)的代码再嵌套循环了一遍

```
6. 立方阶O(n³)

    类似平方阶O(n²)的嵌套循环


7. 空间复杂度O(n)

    空间复杂度的分析跟时间类似，关注开辟空间最多的代码

```js 
    let arr =  new Array(n)
    for(let i = 0; i < n; i++) {
        arr[i] = i
    }
    //  第一行开了n的空间，后续没有新的空间开辟
    // S(n) = O(n)
```